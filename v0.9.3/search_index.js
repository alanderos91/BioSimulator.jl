var documenterSearchIndex = {"docs":
[{"location":"man/plotting/#Basics-1","page":"Plotting","title":"Basics","text":"","category":"section"},{"location":"man/plotting/#","page":"Plotting","title":"Plotting","text":"ENV[\"GKSwstype\"] = \"nul\"\n\nusing BioSimulator, Plots\n\ngr(fmt = :png, dpi = 200)\n\npkgdir = BioSimulator |> pathof |> dirname |> dirname\ninclude(joinpath(pkgdir, \"test\", \"test-models\", \"autoreg.jl\"))\n\nnetwork = neg_autoreg();\nstate, model = BioSimulator.parse_model(network);\nresult = [simulate(state, model, SortingDirect(), tfinal = 500.0, save_points = 0:25:500.0) for _ in 1:100];","category":"page"},{"location":"man/plotting/#","page":"Plotting","title":"Plotting","text":"The plotting defaults provided by BioSimulator.jl require the Plots.jl package. You can install it with","category":"page"},{"location":"man/plotting/#","page":"Plotting","title":"Plotting","text":"Pkg.add(\"Plots\")","category":"page"},{"location":"man/plotting/#","page":"Plotting","title":"Plotting","text":"BioSimulator.jl does not load the Plots.jl package by default. Any time you need plotting functionality, simply load the package:","category":"page"},{"location":"man/plotting/#","page":"Plotting","title":"Plotting","text":"# if BioSimulator is already loaded\nusing Plots\n\n# if you're just starting\nusing BioSimulator, Plots","category":"page"},{"location":"man/plotting/#","page":"Plotting","title":"Plotting","text":"Note that Plots.jl is independent of BioSimulator.jl. Please consult the Plots.jl documentation for additional details.","category":"page"},{"location":"man/plotting/#","page":"Plotting","title":"Plotting","text":"","category":"page"},{"location":"man/plotting/#","page":"Plotting","title":"Plotting","text":"BioSimulator.jl provides a few plotting recipes to quickly summarize simulation results. The type of plot is controlled by a summary keyword. The available options include:","category":"page"},{"location":"man/plotting/#","page":"Plotting","title":"Plotting","text":"summary = :trajectory: An individual SamplePath.\nsummary = :mean: Averaged trajectories based on an Ensemble.\nsummary = :histogram: A histogram based on an Ensemble.\nsummary = :phase: A phase portrait of the stochastic system. The default puts the first component on x-axis and the second component on the y-axis.","category":"page"},{"location":"man/plotting/#","page":"Plotting","title":"Plotting","text":"See the following examples on how to use the default recipes.","category":"page"},{"location":"man/plotting/#Sample-trajectories-1","page":"Plotting","title":"Sample trajectories","text":"","category":"section"},{"location":"man/plotting/#","page":"Plotting","title":"Plotting","text":"# `result` is an `Ensemble` of 100 trajectories\nplot(result[1], summary = :trajectory,\n    xlabel = \"time\", ylabel = \"count\",\n    label = [\"gene\" \"P2_gene\" \"mRNA\" \"P\" \"P2\"])","category":"page"},{"location":"man/plotting/#Mean-trajectories-1","page":"Plotting","title":"Mean trajectories","text":"","category":"section"},{"location":"man/plotting/#","page":"Plotting","title":"Plotting","text":"# select data for protein `P` and dimer `P2` with their indices\nplot(result, summary = :mean,\n    xlabel = \"time\", ylabel = \"average\",\n    vars = [4,5], label = [\"P\" \"P2\"])","category":"page"},{"location":"man/plotting/#Distributions-1","page":"Plotting","title":"Distributions","text":"","category":"section"},{"location":"man/plotting/#","page":"Plotting","title":"Plotting","text":"# 3 figures on top row, 2 on the bottom\nmylayout = @layout [a{0.33w} a{0.33w} a{0.33w}\n                        a{0.5w} a{0.5w}]\n\nplot(result, summary = :histogram,\n    ylabel = \"probability\",\n    timepoint = 500.0, normalize = :probability, bins = :sturges,\n    layout = mylayout,\n    label = [\"gene\" \"P2_gene\" \"mRNA\" \"P\" \"P2\"])","category":"page"},{"location":"man/plotting/#Phase-plots-1","page":"Plotting","title":"Phase plots","text":"","category":"section"},{"location":"man/plotting/#","page":"Plotting","title":"Plotting","text":"For a SamplePath:","category":"page"},{"location":"man/plotting/#","page":"Plotting","title":"Plotting","text":"plot(result[1], summary = :phase,\n    vars = (4,5), xlabel = \"P\", ylabel = \"P2\", colorbar = true)","category":"page"},{"location":"man/plotting/#","page":"Plotting","title":"Plotting","text":"For an Ensemble:","category":"page"},{"location":"man/plotting/#","page":"Plotting","title":"Plotting","text":"plot(result, summary = :phase,\n    vars = (4,5), xlabel = \"P\", ylabel = \"P2\", colorbar = true)","category":"page"},{"location":"man/plotting/#Configurations-(Lattice-based-models)-1","page":"Plotting","title":"Configurations (Lattice-based models)","text":"","category":"section"},{"location":"man/plotting/#","page":"Plotting","title":"Plotting","text":"You can visualize individual configurations in 2D or 3D:","category":"page"},{"location":"man/plotting/#","page":"Plotting","title":"Plotting","text":"plot(result[10])","category":"page"},{"location":"man/plotting/#","page":"Plotting","title":"Plotting","text":"A SamplePath is visualized by plotting the initial and final configuration:","category":"page"},{"location":"man/plotting/#","page":"Plotting","title":"Plotting","text":"plot(result)","category":"page"},{"location":"man/plotting/#General-tips-1","page":"Plotting","title":"General tips","text":"","category":"section"},{"location":"man/plotting/#","page":"Plotting","title":"Plotting","text":"The components of a SamplePath follow the same order in the Network definition. For example, if we define X, Y, and Z in our model, then their indices are 1, 2, and 3, respectively.\nBy default, every variable will appear in a plot (except for phase portraits). You can select a few variables using the var keyword argument.","category":"page"},{"location":"man/citing/#","page":"Citing","title":"Citing","text":"Development of this software was supported by grants. If you use BioSimulator.jl in your research, we ask that you cite the package as follows:","category":"page"},{"location":"man/citing/#","page":"Citing","title":"Citing","text":"Landeros A, Stutz, T, Keys, KL, Alekseyenko, A, Sinsheimer, JS, Lange, K, & Sehl, ME (2018) BioSimulator. jl: Stochastic simulation in Julia. Computer Methods and Programs in Biomedicine 167, 23-35.","category":"page"},{"location":"man/citing/#","page":"Citing","title":"Citing","text":"Convenient BibTeX code:","category":"page"},{"location":"man/citing/#","page":"Citing","title":"Citing","text":"@article{landeros2018biosimulator,\n    title     = {{BioSimulator.jl: Stochastic simulation in Julia}},\n    author    = {Landeros, Alfonso and Stutz, Timothy and Keys, Kevin L and Alekseyenko, Alexander and Sinsheimer, Janet S and Lange, Kenneth and Sehl, Mary E},\n    journal   = {{Computer Methods and Programs in Biomedicine}},\n    volume    = {167},\n    pages     = {23--35},\n    year      = {2018},\n    publisher = {Elsevier}\n}","category":"page"},{"location":"man/algorithms/#Algorithms-1","page":"Algorithms and References","title":"Algorithms","text":"","category":"section"},{"location":"man/algorithms/#","page":"Algorithms and References","title":"Algorithms and References","text":"CurrentModule = BioSimulator","category":"page"},{"location":"man/algorithms/#Exact-algorithms-1","page":"Algorithms and References","title":"Exact algorithms","text":"","category":"section"},{"location":"man/algorithms/#Direct-methods-1","page":"Algorithms and References","title":"Direct methods","text":"","category":"section"},{"location":"man/algorithms/#","page":"Algorithms and References","title":"Algorithms and References","text":"Direct\nEnhancedDirect\nSortingDirect","category":"page"},{"location":"man/algorithms/#BioSimulator.Direct","page":"Algorithms and References","title":"BioSimulator.Direct","text":"Direct()\n\nGillespie's Direct Method.\n\nReferences\n\nGillespie, D.T. (1976) A general method for numerically simulating the stochastic time evolution of coupled chemical reactions. Journal of Computational Physics. https://doi.org/10.1016/0021-9991(76)90041-3\nGillespie, D.T. (1977) Exact stochastic simulation of coupled chemical reactions. The Journal of Physical Chemistry. https://doi.org/10.1021/j100540a008\n\n\n\n\n\n","category":"type"},{"location":"man/algorithms/#BioSimulator.EnhancedDirect","page":"Algorithms and References","title":"BioSimulator.EnhancedDirect","text":"EnhancedDirect()\n\nA Direct method that uses a dependency graph.\n\nReferences\n\nMarchetti L., Priami C., Thanh V.H. (2017) Simulation Algorithms for Computational Systems Biology. Texts in Theoretical Computer Science.\n\n\n\n\n\n","category":"type"},{"location":"man/algorithms/#BioSimulator.SortingDirect","page":"Algorithms and References","title":"BioSimulator.SortingDirect","text":"SortingDirect()\n\nThe sorting direct method reorders reactions to identify frequently occurring events. This effectively reduces the search depth in selecting the next reaction.\n\nReferences\n\nMcCollum, J.M., Peterson, G.D., Cox, C.D., Simpson, M.L., Samatova, N.F. (2006). The sorting direct method for stochastic simulation of biochemical systems with varying reaction execution behavior. Computational Biology and Chemistry. https://doi.org/10.1016/j.compbiolchem.2005.10.007.\n\n\n\n\n\n","category":"type"},{"location":"man/algorithms/#First-reaction-methods-1","page":"Algorithms and References","title":"First reaction methods","text":"","category":"section"},{"location":"man/algorithms/#","page":"Algorithms and References","title":"Algorithms and References","text":"FirstReaction\nNextReaction","category":"page"},{"location":"man/algorithms/#BioSimulator.FirstReaction","page":"Algorithms and References","title":"BioSimulator.FirstReaction","text":"FirstReaction()\n\nA first reaction method that samples reaction events and times jointly.\n\nReferences\n\nGillespie, D.T. (1976) A general method for numerically simulating the stochastic time evolution of coupled chemical reactions. Journal of Computational Physics. https://doi.org/10.1016/0021-9991(76)90041-3\n\n\n\n\n\n","category":"type"},{"location":"man/algorithms/#BioSimulator.NextReaction","page":"Algorithms and References","title":"BioSimulator.NextReaction","text":"NextReaction()\n\nGibson and Bruck's next reaction method. Uses a priority queue to select the next reaction event and time.\n\nReferences\n\nGibson, M.A., Bruck, J. (1999) Efficient exact stochastic simulation of chemical systems with many species and many channels. Journal of Physical Chemistry. https://doi.org/10.1021/jp993732q\n\n\n\n\n\n","category":"type"},{"location":"man/algorithms/#Rejection-methods-1","page":"Algorithms and References","title":"Rejection methods","text":"","category":"section"},{"location":"man/algorithms/#","page":"Algorithms and References","title":"Algorithms and References","text":"RejectionSSA","category":"page"},{"location":"man/algorithms/#BioSimulator.RejectionSSA","page":"Algorithms and References","title":"BioSimulator.RejectionSSA","text":"RejectionSSA()\n\nA rejection-based algorithm that operates on \"virtual states\" to accelerate simulation.\n\nWARNING: This implementation is a work in progress.\n\nReferences\n\nThahn, V.H., Priami, C., Zunino, R. (2014) Efficient rejection-based simulation of biochemical reactions with stochastic noise and delays. Journal of Chemical Physics. https://doi.org/10.1063/1.4896985\n\n\n\n\n\n","category":"type"},{"location":"man/algorithms/#Approximate-algorithms-1","page":"Algorithms and References","title":"Approximate algorithms","text":"","category":"section"},{"location":"man/algorithms/#","page":"Algorithms and References","title":"Algorithms and References","text":"Note: These implementations are a work in progress. The TauLeapingDG2001 and TauLeapingDGLP2003 methods need \"hybrid\" counterparts.","category":"page"},{"location":"man/algorithms/#","page":"Algorithms and References","title":"Algorithms and References","text":"TauLeapingDG2001\nTauLeapingDGLP2003\nStepAnticipation\nHybridSAL","category":"page"},{"location":"man/algorithms/#BioSimulator.TauLeapingDG2001","page":"Algorithms and References","title":"BioSimulator.TauLeapingDG2001","text":"TauLeapingDG2001()\n\nA pure tau-leaping method using the Equation (26a) to select tau.\n\nOptional Arguments\n\nWork in progress.\n\nReferences\n\nGillespie, D.T. (2001) Approximate accelerated stochastic simulation of chemically reacting systems. Journal of Chemical Physics. https://doi.org/10.1063/1.1378322\n\n\n\n\n\n","category":"type"},{"location":"man/algorithms/#BioSimulator.TauLeapingDGLP2003","page":"Algorithms and References","title":"BioSimulator.TauLeapingDGLP2003","text":"TauLeapingDGLP2003()\n\nA pure tau-leaping method using the Equation (6) to select tau.\n\nOptional Arguments\n\nWork in progress.\n\nReferences\n\nGillespie, D.T., Petzold, L.R. (2003) Improved leap-size selection for accelerated stochastic simulation. Journal of Chemical Physics. https://doi.org/10.1063/1.1613254\n\n\n\n\n\n","category":"type"},{"location":"man/algorithms/#BioSimulator.StepAnticipation","page":"Algorithms and References","title":"BioSimulator.StepAnticipation","text":"StepAnticipation()\n\nA pure tau-leaping method using the Equation (15) to select tau.\n\nOptional Arguments\n\nWork in progress.\n\nReferences\n\nSehl, M.E., Alekseyenko, A.L., Lange, K.L. (2009) Accurate stochastic simulation via the step anticipation tau-leaping (SAL) algorithm. Journal of Computational Biology. https://dx.doi.org/10.1089/cmb.2008.0249\n\n\n\n\n\n","category":"type"},{"location":"man/algorithms/#BioSimulator.HybridSAL","page":"Algorithms and References","title":"BioSimulator.HybridSAL","text":"HybridSAL()\n\nSame as StepAnticipation(), but defaults to Direct() depending on the cumulative intensity.\n\nOptional Arguments\n\nWork in progress.\n\nReferences\n\nSehl, M.E., Alekseyenko, A.L., Lange, K.L. (2009) Accurate stochastic simulation via the step anticipation tau-leaping (SAL) algorithm. Journal of Computational Biology. https://dx.doi.org/10.1089/cmb.2008.0249\n\n\n\n\n\n","category":"type"},{"location":"man/tutorials/#","page":"Tutorials","title":"Tutorials","text":"using BioSimulator\n\npkgdir = BioSimulator |> pathof |> dirname |> dirname\ninclude(joinpath(pkgdir, \"test\", \"test-models\", \"autoreg.jl\"))\n\nnetwork = neg_autoreg();\nstate, model = BioSimulator.parse_model(network);","category":"page"},{"location":"man/tutorials/#Accessing-simulation-data-1","page":"Tutorials","title":"Accessing simulation data","text":"","category":"section"},{"location":"man/tutorials/#","page":"Tutorials","title":"Tutorials","text":"A single run generates a SamplePath object which is a recursive array provided by RecursiveArrayTools.jl.","category":"page"},{"location":"man/tutorials/#","page":"Tutorials","title":"Tutorials","text":"sample_path = simulate(state, model, SortingDirect(), tfinal = 100.0, save_points = 0:25:100.0)\n\nsample_path","category":"page"},{"location":"man/tutorials/#","page":"Tutorials","title":"Tutorials","text":"Access the state at the first time point:","category":"page"},{"location":"man/tutorials/#","page":"Tutorials","title":"Tutorials","text":"sample_path[1]","category":"page"},{"location":"man/tutorials/#","page":"Tutorials","title":"Tutorials","text":"Access the third component at the second time point:","category":"page"},{"location":"man/tutorials/#","page":"Tutorials","title":"Tutorials","text":"sample_path[3,2]","category":"page"},{"location":"man/tutorials/#","page":"Tutorials","title":"Tutorials","text":"Access entire history for the third and fourth components:","category":"page"},{"location":"man/tutorials/#","page":"Tutorials","title":"Tutorials","text":"sample_path[[3,4], :]","category":"page"},{"location":"man/tutorials/#","page":"Tutorials","title":"Tutorials","text":"Running multiple simulations generates an Ensemble, a collection of SamplePath objects; that is, Vector{SamplePath}. These objects also support indexing:","category":"page"},{"location":"man/tutorials/#","page":"Tutorials","title":"Tutorials","text":"# ensemble of 10 trajectories\nensemble = [simulate(state, model, SortingDirect(), tfinal = 100.0, save_points = 0:25:100.0) for _ in 1:10];","category":"page"},{"location":"man/tutorials/#","page":"Tutorials","title":"Tutorials","text":"Retrieve an individual sample path:","category":"page"},{"location":"man/tutorials/#","page":"Tutorials","title":"Tutorials","text":"ensemble[2]","category":"page"},{"location":"man/tutorials/#","page":"Tutorials","title":"Tutorials","text":"Index into a SamplePath:","category":"page"},{"location":"man/tutorials/#","page":"Tutorials","title":"Tutorials","text":"ensemble[2][[3,4], :]","category":"page"},{"location":"man/tutorials/#Working-with-DataFrames-1","page":"Tutorials","title":"Working with DataFrames","text":"","category":"section"},{"location":"man/tutorials/#","page":"Tutorials","title":"Tutorials","text":"Both SamplePath and Ensemble implement the IterableTables.jl interface. This means that they act as data sources that can be converted into any supported data sink. For example, you can convert an Ensemble into a DataFrame:","category":"page"},{"location":"man/tutorials/#","page":"Tutorials","title":"Tutorials","text":"using DataFrames\n\nDataFrame(ensemble)","category":"page"},{"location":"man/tutorials/#","page":"Tutorials","title":"Tutorials","text":"Each component of the state vector appears as a column, along with trajectory trial and timestamp t columns. If the conversion does not produce the expected result, one may be able to force the correct behavior using the tablefy function:","category":"page"},{"location":"man/tutorials/#","page":"Tutorials","title":"Tutorials","text":"import BioSimulator: tablefy\n\nDataFrame(tablefy(sample_path)) # DataFrame(sample_path) is currently incorrect","category":"page"},{"location":"man/tutorials/#Saving-simulation-results-1","page":"Tutorials","title":"Saving simulation results","text":"","category":"section"},{"location":"man/tutorials/#","page":"Tutorials","title":"Tutorials","text":"Because SamplePath and Ensemble support iteration, you can save simulation data directly using Julia's I/O interface.","category":"page"},{"location":"man/tutorials/#","page":"Tutorials","title":"Tutorials","text":"Example here","category":"page"},{"location":"man/tutorials/#","page":"Tutorials","title":"Tutorials","text":"The easiest approach takes advantage of IterableTables.jl:","category":"page"},{"location":"man/tutorials/#","page":"Tutorials","title":"Tutorials","text":"using CSV\n\nCSV.write(file, result, delim = '\\t')","category":"page"},{"location":"man/tutorials/#Obtaining-summary-statistics-1","page":"Tutorials","title":"Obtaining summary statistics","text":"","category":"section"},{"location":"man/tutorials/#","page":"Tutorials","title":"Tutorials","text":"Summary statistics for ensembles are supported directly:","category":"page"},{"location":"man/tutorials/#","page":"Tutorials","title":"Tutorials","text":"using Statistics\n\nmean(ensemble)\nstd(result)\nvar(result)","category":"page"},{"location":"man/simulation/#Simulation-1","page":"Simulation","title":"Simulation","text":"","category":"section"},{"location":"man/simulation/#","page":"Simulation","title":"Simulation","text":"CurrentModule = BioSimulator","category":"page"},{"location":"man/simulation/#","page":"Simulation","title":"Simulation","text":"parse_model\nsimulate","category":"page"},{"location":"man/simulation/#BioSimulator.parse_model","page":"Simulation","title":"BioSimulator.parse_model","text":"parse_model(network::Network)\n\nConstruct a state <: Vector{Int} and model <: ReactionSystem from a Network object.\n\nUse this in simulate to avoid constructing internal data structures over multiple samples.\n\n\n\n\n\n","category":"function"},{"location":"man/simulation/#BioSimulator.simulate","page":"Simulation","title":"BioSimulator.simulate","text":"simulate(network::Network, algname::SimulationAlgorithm;\n            [tfinal = 0.0],\n            [rates_cache = HasRates],\n            [save_points = nothing],\n            [save_function = __extract])\n\nSimulate a Network of interacting populations. Note that simulations may terminate early if the cumulative intensity reaches 0 (that is, reaching an absorbing state).\n\nKeyword Arguments\n\ntfinal: The final simulation time.\nrates_cache: Indicates the type of information stored in a rates cache. If HasRates is chosen, store the actual rates. If HasSums is chosen, store partial sums of the rates. This effectively toggles between linear and binary searches, provided the algorithm supports the option.\nsave_points: An indexable collection indicating time points to sample and record system state. The default nothing forces saving after every reaction event.\nsave_function: A three argument function that maps the three arguments (simulator, state, model) to data recorded in a SamplePath. Default behavior is to record each species.\n\n\n\n\n\nsimulate(state, model, algname::SimulationAlgorithm;\n            [tfinal = 0.0],\n            [rates_cache = HasRates],\n            [save_points = nothing],\n            [save_function = __extract])\n\nSimulate a model with the given initial state. Note that simulations may terminate early if the cumulative intensity reaches 0 (that is, reaching an absorbing state).\n\nArguments\n\nFor well-mixed systems:\n\nstate: A Vector{Int} constructed by parse_model.\nmodel: A ReactionSystem type constructed by parse_model.\n\nFor lattice-based systems:\n\nstate: A Lattice type whose topology comptabile is compatible with model.\nmodel: An InteractingParticleSystem type built from @enumerate_with_sclass.\n\nKeyword Arguments\n\ntfinal: The final simulation time.\nrates_cache: Indicates the type of information stored in a rates cache. If HasRates is chosen, store the actual rates. If HasSums is chosen, store partial sums of the rates. This effectively toggles between linear and binary searches, provided the algorithm supports the option.\nsave_points: An indexable collection indicating time points to sample and record system state. The default nothing forces saving after every reaction event.\nsave_function: A three argument function that maps the three arguments (simulator, state, model) to data recorded in a SamplePath. Default behavior is to store population counts for well-mixed systems or Configuration objects for lattice-based systems.\n\n\n\n\n\n","category":"function"},{"location":"#BioSimulator.jl-1","page":"Home","title":"BioSimulator.jl","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"A stochastic simulation framework for Julia.","category":"page"},{"location":"#Introduction-1","page":"Home","title":"Introduction","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"Many complex systems in biology are analytically intractable, and dynamical predictions based on deterministic models can be grossly misleading. Stochastic simulation algorithms based on continuous-time Markov chains allow researchers to generate accurate time-evolution trajectories, test the sensitivity of models to key parameters, and quantify frequencies of rare events.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Situations where stochastic simulation is especially helpful involve:","category":"page"},{"location":"#","page":"Home","title":"Home","text":"rare events such as extinction and mutation,\nkey molecules present in small numbers,\nrare reactions with dramatic influence on the dynamics of the system\npopulation cycles arising from demographic stochasticity.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Examples of such systems include gene expression networks, tumor suppressor pathways, and demographic and ecological systems.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"BioSimulator.jl aims to provide researchers interested in such phenomena with a fast, reliable, user-friendly, and open-source modeling tool in Julia.","category":"page"},{"location":"#Installation-1","page":"Home","title":"Installation","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"BioSimulator.jl can be installed with Julia's package manager at the REPL (note the capitalization in URLs):","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Option 1: Directly with Pkg","category":"page"},{"location":"#","page":"Home","title":"Home","text":"using Pkg\n\nPkg.add(\"https://github.com/alanderos91/BioSimulator.jl.git\")","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Option 2: Press ] to enter pkg mode and enter the following:","category":"page"},{"location":"#","page":"Home","title":"Home","text":"pkg> add https://github.com/alanderos91/BioSimulator.jl.git","category":"page"},{"location":"#","page":"Home","title":"Home","text":"You can start using BioSimulator.jl in scripts or the REPL with the command:","category":"page"},{"location":"#","page":"Home","title":"Home","text":"using BioSimulator","category":"page"},{"location":"man/model-specification/#Overview-1","page":"Model Specification","title":"Overview","text":"","category":"section"},{"location":"man/model-specification/#","page":"Model Specification","title":"Model Specification","text":"BioSimulator.jl simulates stochastic dynamical systems using Markov chain theory. Because transition probabilities are usually unavailable and infinitesimal generators are often impractical, we provide a few modeling objects to represent a chain. Two cases are handled: well-mixed and lattice-based systems. Here the term \"well-mixed\" is taken to mean that the underlying space for a chain concerns discrete quantities and/or vectors (non-spatial), whereas lattice-based systems model configurations of interacting particles (spatial).","category":"page"},{"location":"man/model-specification/#Well-Mixed-Systems-1","page":"Model Specification","title":"Well-Mixed Systems","text":"","category":"section"},{"location":"man/model-specification/#","page":"Model Specification","title":"Model Specification","text":"A Network object summarizes interactions between populations. Each Species participates in at least one Reaction. For example, the following code defines a birth-death-immigration process in BioSimulator.jl's modeling language:","category":"page"},{"location":"man/model-specification/#","page":"Model Specification","title":"Model Specification","text":"# initialize\nnetwork = Network(\"BDI\")\n\n# species definitions; add components with <=\nnetwork <= Species(\"X\", 5)\n\n# reaction definitions\nnetwork <= Reaction(\"birth\", 2.0, \"X --> X + X\")\nnetwork <= Reaction(\"death\", 1.0, \"X --> 0\")\nnetwork <= Reaction(\"immigration\", 0.5, \"0 --> X\")","category":"page"},{"location":"man/model-specification/#Lattice/Cellular-Automata-1","page":"Model Specification","title":"Lattice/Cellular Automata","text":"","category":"section"},{"location":"man/model-specification/#","page":"Model Specification","title":"Model Specification","text":"Interacting Particle Systems (IPSs) are defined using the @def_reactions macro. The syntax resembles chemical reaction notation but the + symbol implies directionality; for example:","category":"page"},{"location":"man/model-specification/#","page":"Model Specification","title":"Model Specification","text":"interactions = @def_reactions begin\n    X + 0 --> 0 + X, α\n    X + Y --> Z + 0, β\n    Z --> 0, α\nend α β","category":"page"},{"location":"man/model-specification/#","page":"Model Specification","title":"Model Specification","text":"The first interaction reads as \"X moves to an empty site\" (swapping locations). The second is taken to mean \"X interacts with an adjacent Y to form Z at the same location as X, with Y being consumed in the process\". However, this construction not contain any spatial information. You can specify a topology using @enumerate_with_sclass:","category":"page"},{"location":"man/model-specification/#","page":"Model Specification","title":"Model Specification","text":"model = @enumerate_with_sclass interactions VonNeumann() 2","category":"page"},{"location":"man/model-specification/#","page":"Model Specification","title":"Model Specification","text":"This command \"compiles\" a 2-D version of the IPS in which interactions are between nearest-neighbors along cardinal directions. Initial conditions are specified with a Lattice object:","category":"page"},{"location":"man/model-specification/#","page":"Model Specification","title":"Model Specification","text":"state = Lattice(coordinates, ...)","category":"page"}]
}
