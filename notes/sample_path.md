
````julia
using InteractiveUtils
using NewBioSimulator
using Plots
````



````
Julia Version 1.1.0
Commit 80516ca202 (2019-01-21 21:24 UTC)
Platform Info:
  OS: macOS (x86_64-apple-darwin18.2.0)
  CPU: Intel(R) Core(TM) i7-4750HQ CPU @ 2.00GHz
  WORD_SIZE: 64
  LIBM: libopenlibm
  LLVM: libLLVM-6.0.1 (ORCJIT, haswell)
Environment:
  JULIA_EDITOR = atom  -a
  JULIA_NUM_THREADS = 4
````





## Example model

````julia
include(joinpath(@__DIR__, "test", "test-models", "kendall.jl"))

m = kendall()
m.reaction_list
````


````
OrderedCollections.OrderedDict{Symbol,Reaction} with 3 entries:
  :birth       => X -> 2 X…
  :death       => X -> ∅…
  :immigration => ∅ -> X…
````





## The SamplePath struct

Our software simulates stochastic processes $\{X_{t}\}_{t \ge 0}$ governed by Markovian dynamics.
A *sample path*, denoted $X_{t}(\omega)$, is a particular realization of the process.
This is precisely the type of data (time series) generated by `simulate`, independent of whether the state space involves population counts (well-mixed) or configurations of particles (lattice-based).
Namely, we need to keep track of each observation `u` and its time of observation `t`.
Because the observed values of well-mixed processes are vectors, our new `SamplePath` object is based on the work of RecursiveArrayTools.jl.

**NB: The ideas in that package may one day be migrated to Base. It's better than spinning up our own implementation.**

````julia

struct SamplePath{T,N,A,B} <: AbstractVectorOfArray{T, N}
  u::A
  t::B
end
````




### Basic functionality

First let's generate a single realization of the birth-death-immigration process:

````julia
# note: the parse_model business will go away one day
state, model = NewBioSimulator.parse_model(m)

# so will HasRates
xw = simulate(state, model, Direct(), 4.0, HasRates)
````


````
t: 482-element Array{Float64,1}:
 0.0                
 0.13084247170799324
 0.17074686526426286
 0.18620797092000443
 0.1973361949977582 
 0.4554990852095395 
 0.5431132595796091 
 0.6020716270210175 
 0.7079938125428702 
 0.7788194002509797 
 ⋮                  
 3.983286224512406  
 3.985384069033345  
 3.988353606264356  
 3.9923123927731363 
 3.995549236439951  
 3.9973575497967833 
 3.998955631694999  
 3.9991822761780385 
 4.0                
x: 482-element Array{Array{Int64,1},1}:
 [5]  
 [6]  
 [5]  
 [4]  
 [3]  
 [4]  
 [5]  
 [6]  
 [7]  
 [8]  
 ⋮    
 [150]
 [151]
 [152]
 [153]
 [154]
 [153]
 [152]
 [153]
 [153]
````





#### Array interface

Get the value of the process at the $k$-th time step:
````julia
xw[1]
````


````
1-element Array{Int64,1}:
 5
````





Get the value of the $j$-th component at the $k$-th time step:
````julia
xw[1, end]
````


````
153
````





Support for the `Colon` and range indexing:
````julia
xw[:, 1]
````


````
1-element Array{Int64,1}:
 5
````



````julia
xw[1, 1:3]
````


````
3-element Array{Int64,1}:
 5
 6
 5
````





We can even iterate over the object:
````julia
# note you can try computing the sum using a for loop
# but it does not work unless you put the computation in a function
# it causes a weird variable scoping issue; may be a bug
sum(xw[1,i] for i in eachindex(xw))
````


````
39600
````



````julia
sum(xw)
````


````
1-element Array{Int64,1}:
 39600
````





### Plotting

The RecipesBase.jl package provides a nice interface for building visualizations:
````julia

# whenever Plots.jl sees a SamplePath object, replace it with the observation times and values
@recipe function f(xw::SamplePath)
  seriestype --> :steppre

  xw.t, xw'
end

# special case for SamplePath objects whose data is simply a number (as opposed to vector in general)...
@recipe function f(xw::SamplePath{T,1}) where {T}
  seriestype --> :steppre

  xw.t, xw.u
end
````




The `seriestype --> :steppre` syntax is to tell Plots.jl that the data should be plotted as a step function.
Those two recipes are all that are needed to make plotting work:
````julia
plot(xw,
  title  = "a sample path",
  xlabel = "t",
  ylabel = "X_t",
  legend = nothing)
````


![](figures/sample_path_13_1.svg)



## Generating ensembles

Usually we don't care about a single realization of a stochastic process and instead want to compute statistics from several realizations.
Internally, this is handled by the following object:

````julia

Ensemble{T,N,A,B} = Vector{SamplePath{T,N,A,B}}
````




which is an alias for a vector of `SamplePath`s.
As an example, let's generate `10` sample paths of our model:

````julia
ensemble = [simulate(state, model, Direct(), 4.0, HasRates) for i in 1:10]

ensemble[1]
````


````
t: 692-element Array{Float64,1}:
 0.0                
 0.0165915052307431 
 0.05573443582424019
 0.12600578426424275
 0.170143994677652  
 0.1724949674674208 
 0.3054988709459976 
 0.4090310242291978 
 0.440717900264278  
 0.4554536781302372 
 ⋮                  
 3.9905940581851924 
 3.9910541059867777 
 3.992939587330316  
 3.99304746583578   
 3.9939473403682495 
 3.9942969394125503 
 3.995780517578052  
 3.9960712924862767 
 4.0                
x: 692-element Array{Array{Int64,1},1}:
 [5]  
 [4]  
 [3]  
 [4]  
 [5]  
 [4]  
 [5]  
 [4]  
 [5]  
 [4]  
 ⋮    
 [244]
 [245]
 [246]
 [247]
 [248]
 [249]
 [250]
 [249]
 [249]
````





The `Ensemble` alias is just there to make writing code easier.
For example, we can generate a default recipe for ensembles which visualizes a mean path.
This requires us to compute the mean value of the process at a particular time $t$ over several samples indexed by $\{\omega_{1}, \ldots, \omega_{n}\}$.
For now, we have a `get_regular_path` function that builds a `SamplePath` with observations at specific time points.
This is simply a constant interpolation of the data *that necessarily discards information about the process*.

````julia

@recipe function f(ens::Ensemble, epochs = 100)
  # regularize the sample paths
  tfinal = ens[1].t[end]

  reg = get_regular_ensemble(ens, tfinal, epochs)

  # extract the series data
  ts = reg[1].t
  xs = convert(Array, mean(reg)')

  ts, xs
end
````




Here `epochs` lets us specify the number of interpolation points to use.
**NB: We need a better interface and implementation for interpolating data**.

````julia
plot(ensemble, 10,
  title  = "mean path (n = 10)",
  xlabel = "t",
  ylabel = "E(X_t)",
  legend = nothing)
````


![](figures/sample_path_17_1.svg)
