
````julia
using InteractiveUtils
using NewBioSimulator
using Plots
````



````
Julia Version 1.1.0
Commit 80516ca202 (2019-01-21 21:24 UTC)
Platform Info:
  OS: macOS (x86_64-apple-darwin18.2.0)
  CPU: Intel(R) Core(TM) i7-4750HQ CPU @ 2.00GHz
  WORD_SIZE: 64
  LIBM: libopenlibm
  LLVM: libLLVM-6.0.1 (ORCJIT, haswell)
````





## Example model

````julia
NBS = NewBioSimulator |> pathof |> dirname |> dirname
include(joinpath(NBS, "test", "test-models", "kendall.jl"))

m = kendall()
m.reaction_list
````


````
OrderedCollections.OrderedDict{Symbol,NewBioSimulator.Reaction} with 3 entr
ies:
  :birth       => X -> 2 X…
  :death       => X -> ∅…
  :immigration => ∅ -> X…
````





## The SamplePath struct

Our software simulates stochastic processes $\{X_{t}\}_{t \ge 0}$ governed by Markovian dynamics.
A *sample path*, denoted $X_{t}(\omega)$, is a particular realization of the process.
This is precisely the type of data (time series) generated by `simulate`, independent of whether the state space involves population counts (well-mixed) or configurations of particles (lattice-based).
Namely, we need to keep track of each observation `u` and its time of observation `t`.
Because the observed values of well-mixed processes are vectors, our new `SamplePath` object is based on the work of RecursiveArrayTools.jl.

**NB: The ideas in that package may one day be migrated to Base. It's better than spinning up our own implementation.**

````julia

struct SamplePath{T,N,A,B} <: AbstractVectorOfArray{T, N}
  u::A
  t::B
end
````




### Basic functionality

First let's generate a single realization of the birth-death-immigration process:

````julia
# note: the parse_model business will go away one day
state, model = NewBioSimulator.parse_model(m)

# so will HasRates
xw = simulate(state, model, Direct(), 4.0, HasRates)
````


````
t: 331-element Array{Float64,1}:
 0.0                
 0.09361952232069415
 0.1785624419885956 
 0.20444152552655606
 0.28674365026636733
 0.3601487758438865 
 0.4044113810890308 
 0.4420708802896253 
 0.4716846035199837 
 0.48017313879333995
 ⋮                  
 3.9691709097212975 
 3.971544797693818  
 3.980187602834757  
 3.9862979978168758 
 3.987482239736292  
 3.9952819779159343 
 3.9971934623189593 
 3.9999983598177105 
 4.0                
x: 331-element Array{Array{Int64,1},1}:
 [5]  
 [6]  
 [7]  
 [8]  
 [9]  
 [8]  
 [9]  
 [8]  
 [9]  
 [10] 
 ⋮    
 [101]
 [102]
 [103]
 [104]
 [105]
 [106]
 [107]
 [106]
 [106]
````





#### Array interface

Get the value of the process at the $k$-th time step:
````julia
xw[1]
````


````
1-element Array{Int64,1}:
 5
````





Get the value of the $j$-th component at the $k$-th time step:
````julia
xw[1, end]
````


````
106
````





Support for the `Colon` and range indexing:
````julia
xw[:, 1]
````


````
1-element Array{Int64,1}:
 5
````



````julia
xw[1, 1:3]
````


````
3-element Array{Int64,1}:
 5
 6
 7
````





We can even iterate over the object:
````julia
# note you can try computing the sum using a for loop
# but it does not work unless you put the computation in a function
# it causes a weird variable scoping issue; may be a bug
sum(xw[1,i] for i in eachindex(xw))
````


````
17037
````



````julia
sum(xw)
````


````
1-element Array{Int64,1}:
 17037
````





### Plotting

The RecipesBase.jl package provides a nice interface for building visualizations:
````julia

# whenever Plots.jl sees a SamplePath object, replace it with the observation times and values
@recipe function f(xw::SamplePath)
  seriestype --> :steppre

  xw.t, xw'
end

# special case for SamplePath objects whose data is simply a number (as opposed to vector in general)...
@recipe function f(xw::SamplePath{T,1}) where {T}
  seriestype --> :steppre

  xw.t, xw.u
end
````




The `seriestype --> :steppre` syntax is to tell Plots.jl that the data should be plotted as a step function.
Those two recipes are all that are needed to make plotting work:
````julia
plot(xw,
  title  = "a sample path",
  xlabel = "t",
  ylabel = "X_t",
  legend = nothing)
````


![](figures/sample_path_13_1.svg)



## Generating ensembles

Usually we don't care about a single realization of a stochastic process and instead want to compute statistics from several realizations.
Internally, this is handled by the following object:

````julia

Ensemble{T,N,A,B} = Vector{SamplePath{T,N,A,B}}
````




which is an alias for a vector of `SamplePath`s.
As an example, let's generate `10` sample paths of our model:

````julia
ensemble = [simulate(state, model, Direct(), 4.0, HasRates) for i in 1:10]

ensemble[1]
````


````
t: 53-element Array{Float64,1}:
 0.0                 
 0.008469619148998872
 0.15622318959590406 
 0.19173863465986973 
 0.25959149289494243 
 0.3565106751351078  
 0.4567876921380534  
 0.6784594552402854  
 0.7738297054187752  
 0.8180983959790816  
 ⋮                   
 3.930304859106143   
 3.9434044797242045  
 3.9800792696740865  
 3.980543299843797   
 3.9873536422631077  
 3.9905887048621347  
 3.994350118933573   
 3.999707295771568   
 4.0                 
x: 53-element Array{Array{Int64,1},1}:
 [5] 
 [4] 
 [3] 
 [4] 
 [3] 
 [2] 
 [3] 
 [4] 
 [5] 
 [4] 
 ⋮   
 [19]
 [20]
 [21]
 [22]
 [23]
 [22]
 [23]
 [22]
 [22]
````





The `Ensemble` alias is just there to make writing code easier.
For example, we can generate a default recipe for ensembles which visualizes a mean path.
This requires us to compute the mean value of the process at a particular time $t$ over several samples indexed by $\{\omega_{1}, \ldots, \omega_{n}\}$.
For now, we have a `get_regular_path` function that builds a `SamplePath` with observations at specific time points.
This is simply a constant interpolation of the data *that necessarily discards information about the process*.

````julia

@recipe function f(ens::Ensemble, epochs = 100)
  # regularize the sample paths
  tfinal = ens[1].t[end]

  reg = get_regular_ensemble(ens, tfinal, epochs)

  # extract the series data
  ts = reg[1].t
  xs = convert(Array, mean(reg)')

  ts, xs
end
````




Here `epochs` lets us specify the number of interpolation points to use.
**NB: We need a better interface and implementation for interpolating data**.

````julia
plot(ensemble, 10,
  title  = "mean path (n = 10)",
  xlabel = "t",
  ylabel = "E(X_t)",
  legend = nothing)
````


![](figures/sample_path_17_1.svg)
