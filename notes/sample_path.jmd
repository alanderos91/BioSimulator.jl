---
title: SamplePath interface
author: Alfonso Landeros
options:
  fig_ext: .svg
---

```{julia}
using InteractiveUtils
using NewBioSimulator
using Plots
```

```{julia; echo=false}
versioninfo()
```

## Example model

```{julia}
NBS = NewBioSimulator |> pathof |> dirname |> dirname
include(joinpath(NBS, "test", "test-models", "kendall.jl"))

m = kendall()
m.reaction_list
```

## The SamplePath struct

Our software simulates stochastic processes $\{X_{t}\}_{t \ge 0}$ governed by Markovian dynamics.
A *sample path*, denoted $X_{t}(\omega)$, is a particular realization of the process.
This is precisely the type of data (time series) generated by `simulate`, independent of whether the state space involves population counts (well-mixed) or configurations of particles (lattice-based).
Namely, we need to keep track of each observation `u` and its time of observation `t`.
Because the observed values of well-mixed processes are vectors, our new `SamplePath` object is based on the work of RecursiveArrayTools.jl.

**NB: The ideas in that package may one day be migrated to Base. It's better than spinning up our own implementation.**

```{julia; eval=false}
struct SamplePath{T,N,A,B} <: AbstractVectorOfArray{T, N}
  u::A
  t::B
end
```

### Basic functionality

First let's generate a single realization of the birth-death-immigration process:

```{julia}
# note: the parse_model business will go away one day
state, model = NewBioSimulator.parse_model(m)

# so will HasRates
xw = simulate(state, model, Direct(), 4.0, HasRates)
```

#### Array interface

Get the value of the process at the $k$-th time step:
```{julia}
xw[1]
```

Get the value of the $j$-th component at the $k$-th time step:
```{julia}
xw[1, end]
```

Support for the `Colon` and range indexing:
```{julia}
xw[:, 1]
```

```{julia}
xw[1, 1:3]
```

We can even iterate over the object:
```{julia}
# note you can try computing the sum using a for loop
# but it does not work unless you put the computation in a function
# it causes a weird variable scoping issue; may be a bug
sum(xw[1,i] for i in eachindex(xw))
```

```{julia}
sum(xw)
```

### Plotting

The RecipesBase.jl package provides a nice interface for building visualizations:
```{julia; eval=false}
# whenever Plots.jl sees a SamplePath object, replace it with the observation times and values
@recipe function f(xw::SamplePath)
  seriestype --> :steppre

  xw.t, xw'
end

# special case for SamplePath objects whose data is simply a number (as opposed to vector in general)...
@recipe function f(xw::SamplePath{T,1}) where {T}
  seriestype --> :steppre

  xw.t, xw.u
end
```

The `seriestype --> :steppre` syntax is to tell Plots.jl that the data should be plotted as a step function.
Those two recipes are all that are needed to make plotting work:
```{julia}
plot(xw,
  title  = "a sample path",
  xlabel = "t",
  ylabel = "X_t",
  legend = nothing)
```

## Generating ensembles

Usually we don't care about a single realization of a stochastic process and instead want to compute statistics from several realizations.
Internally, this is handled by the following object:

```{julia; eval = false}
Ensemble{T,N,A,B} = Vector{SamplePath{T,N,A,B}}
```

which is an alias for a vector of `SamplePath`s.
As an example, let's generate `10` sample paths of our model:

```{julia}
ensemble = [simulate(state, model, Direct(), 4.0, HasRates) for i in 1:10]

ensemble[1]
```

The `Ensemble` alias is just there to make writing code easier.
For example, we can generate a default recipe for ensembles which visualizes a mean path.
This requires us to compute the mean value of the process at a particular time $t$ over several samples indexed by $\{\omega_{1}, \ldots, \omega_{n}\}$.
For now, we have a `get_regular_path` function that builds a `SamplePath` with observations at specific time points.
This is simply a constant interpolation of the data *that necessarily discards information about the process*.

```{julia; eval=false}
@recipe function f(ens::Ensemble, epochs = 100)
  # regularize the sample paths
  tfinal = ens[1].t[end]

  reg = get_regular_ensemble(ens, tfinal, epochs)

  # extract the series data
  ts = reg[1].t
  xs = convert(Array, mean(reg)')

  ts, xs
end
```

Here `epochs` lets us specify the number of interpolation points to use.
**NB: We need a better interface and implementation for interpolating data**.

```{julia}
plot(ensemble, 10,
  title  = "mean path (n = 10)",
  xlabel = "t",
  ylabel = "E(X_t)",
  legend = nothing)
```
